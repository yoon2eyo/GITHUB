## 1. 아키텍처 패턴 및 스타일 (Architectural Patterns & Styles)

아키텍처 패턴은 반복적으로 발생하는 문제에 대한 검증된 구조적 해결책이며, 종종 아키텍처 스타일(Architecture Style)과 같은 의미로 사용됩니다.

소스에서 제시된 패턴/스타일은 아키텍처 프레임(Architecture Style Frame)에 따라 분류될 수 있습니다.

| 분류                                 | 스타일/패턴 (Style/Pattern)                 | 설명                                                                                         | 출처  |
| :--------------------------------- | :------------------------------------- | :----------------------------------------------------------------------------------------- | :-- |
| **Data Flow (데이터 흐름)**             | Batch Sequential (배치 순차)               | 프로그램들이 순차적으로 실행되며 데이터가 집합체로 전달됨.                                                           |     |
|                                    | Pipe and Filter (파이프 및 필터)             | 데이터 스트림이 연속적인 변환 과정을 거치며, 재사용 가능하고 느슨하게 결합된 구성 요소로 분할됨.                                    |     |
|                                    | Process Control (프로세스 제어)              | 환경 변수를 제어하기 위한 루프 구조(폐쇄 루프 제어)를 사용하며, 안정적인 수준에서 출력을 유지해야 하는 시스템에 적합함.                      |     |
| **Data Centered (데이터 중심)**         | Shared Repository (공유 저장소)             | 중앙 집중식 데이터 저장소를 중심으로 모든 소프트웨어 구성 요소가 데이터를 공유하고 조작함. 데이터 저장소는 수동적이며 클라이언트가 능동적임.            |     |
|                                    | Blackboard (블랙보드)                      | 데이터 저장소(블랙보드)가 능동적이며, 지식 소스(클라이언트)가 수동적으로 작동함. 주로 지식 기반 AI 시스템에 사용됨.                       |     |
| **Implicit Invocation (암묵적 호출)**   | Event Based (이벤트 기반)                   | 프로시저를 직접 호출하는 대신 이벤트 알림이 다른 모듈의 프로시저 호출을 암묵적으로 유발함. 느슨한 결합이 특징임.                           |     |
|                                    | Message Based (메시지 기반)                 | 메시지 생산자와 소비자가 버퍼(메시지 큐 또는 Pub/Sub 커넥터)를 통해 비동기적으로 연결됨.                                     |     |
| **Interaction-Oriented (상호작용 중심)** | Model-View-Controller (MVC)            | UI를 모델(데이터/비즈니스 로직), 뷰(UI 표시), 컨트롤러(사용자 입력 및 모델/뷰 조정)의 세 부분으로 분리함.                         |     |
|                                    | Presentation-Abstraction-Control (PAC) | 시스템을 계층적 구조의 PAC 에이전트(Presentation, Abstraction, Control)로 분해하며, 각 에이전트는 특정 기능에 대한 책임을 가짐. |     |
| **Hierarchical (계층형)**             | Layered Architecture (계층화 아키텍처)        | 시스템의 관심사를 계층(Layer)으로 분할하여 응집력 있는 서비스 집합을 제공하며, 사용 관계는 단방향으로 제한됨.                          |     |
|                                    | Main-Subroutine (메인-서브루틴)              | 시스템을 기능에 따라 계층적으로 서브루틴으로 분해하며, 단일 제어 스레드를 가짐.                                              |     |
|                                    | Master-Slave (마스터-슬레이브)                | 결함 허용 및 시스템 안정성을 지원하는 아키텍처로, 슬레이브가 마스터에게 복제된 서비스를 제공함.                                     |     |
|                                    | Virtual Machine (가상 머신)                | 기존 시스템 위에 구축되어 가상 추상화 및 속성/운영 집합을 제공함.                                                     |     |
|                                    | Microkernel (마이크로커널)                   | 운영 체제 구현에 필요한 최소한의 기능을 제공하는 코어 시스템과 확장 기능을 제공하는 플러그인 구성 요소를 분리함.                           |     |
| **Distributed (분산형)**              | Multi-tier (N-Tier/3-Tier)             | 기능을 물리적으로 분리된 계층(Tier)으로 분리하며, 계층화 스타일과 유사하나 물리적 분리에 중점을 둠.                                |     |
|                                    | Client-Server (클라이언트-서버)               | 시스템을 클라이언트(요청자)와 서버(서비스 제공자)의 두 프로그램으로 분리함.                                                |     |
|                                    | Broker (브로커)                           | 클라이언트와 서버 사이에 중개자(Broker)를 삽입하여 서비스 사용자가 서비스 제공자의 위치나 성격을 알 필요가 없도록 분리함.                   |     |
|                                    | Service-Oriented (SOA)                 | 서비스를 통해 기능을 노출하고 소비하는 아키텍처 스타일.                                                            |     |
|                                    | Microservice (마이크로서비스)                 | 작고 자율적인 서비스들의 컬렉션으로, 각 서비스는 단일 비즈니스 역량을 구현함 (SOA보다 애플리케이션 범위에 중점).                         |     |
|                                    | Dispatcher (디스패처)                      | 클라이언트의 요청을 받아 적절한 서버를 선택하여 요청을 전달하는 중개자(Dispatcher)를 사용함.                                  |     |
|                                    | Edge-Based (에지 기반)                     | 컴퓨팅 및 데이터 저장을 데이터 소스에 더 가깝게 가져오는 분산 컴퓨팅 패러다임.                                              |     |

---

## 2. 특정 설계 영역 패턴 (Specific Design Patterns)

소스에는 특정 엔지니어링 결정이나 애플리케이션 유형에 초점을 맞춘 다양한 디자인 패턴도 언급되어 있습니다.

|분류|패턴 (Pattern)|설명|출처|
|:--|:--|:--|:--|
|**데이터 접근/영속성**|**Active Record**|도메인 엔티티 내에 데이터 접근 객체를 포함함.||
||**Repository**|도메인 엔티티와 작동하는 데이터 소스의 인메모리 표현.||
||**Data Mapper**|객체와 데이터베이스 간의 변환을 담당하는 계층.||
||**Domain Model**|도메인 내의 엔티티 및 관계를 나타내는 비즈니스 객체 집합.||
||**Transaction Script**|각 트랜잭션에 대한 비즈니스 로직을 단일 프로시저로 구성함.||
|**트랜잭션/동시성**|**Optimistic/Pessimistic Offline Lock**|다른 세션의 변경 사항과 충돌하지 않도록 보장함.||
||**Capture Transaction Details**|트랜잭션에 속하는 모든 테이블의 변경 사항을 기록하기 위해 트리거 및 섀도 테이블과 같은 데이터베이스 객체를 생성함.||
|**프레젠테이션/UI**|**Page Cache**|자주 접근하지만 변경은 덜 빈번한 동적 웹 페이지의 응답 시간을 개선함.||
||**Front Controller**|모든 요청을 단일 핸들러 객체(컨트롤러)를 통해 처리하도록 중앙 집중화함.||
||**Composite View**|개별 뷰를 복합적인 표현으로 결합함.||
||**Presentation Model**|모든 뷰 로직과 상태를 뷰에서 분리하여 데이터 바인딩 및 템플릿을 통해 뷰를 렌더링함.||
|**서비스/메시징**|**Service Interface**|다른 시스템이 서비스와 상호작용하는 데 사용할 수 있는 프로그래밍 인터페이스.||
||**Application Façade (Remote Façade)**|여러 비즈니스 작업을 단일 메시지 기반 작업으로 결합하여 통합 인터페이스를 제공함.||
||**Message Bus / Message Broker**|메시지를 수신 및 전송할 수 있는 소프트웨어 시스템.||
|**배포/안정성**|**Load-Balanced Cluster**|여러 서버가 워크로드를 공유하도록 구성되어 성능 및 안정성을 향상시킴.||
||**Failover Cluster**|서버 중 하나가 실패할 경우 다른 서버가 자동으로 작업을 인계하도록 구성된 서버 집합.||
||**Trusted Subsystem**|애플리케이션이 사용자 자격 증명 대신 자체 자격 증명을 사용하여 리소스에 접근하는 패턴.||
|**워크플로우**|**Sequential Workflow**|작업들이 순서대로 진행되는 워크플로우.||
||**State-Driven Workflow**|시스템 상태에 따라 작업 순서가 결정되는 워크플로우.||

---

## 3. 아키텍처 택틱 (Architectural Tactics)

택틱은 아키텍처 패턴을 구성하는 기본 요소이며, 품질 속성(Quality Attributes)을 달성하는 데 초점을 맞춘 설계 결정입니다.

### A. 가용성 택틱 (Availability Tactics)

가용성은 시스템이 고장을 마스킹하거나 수리하여 서비스 중단 시간을 최소화하는 능력입니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**결함 감지** (Fault Detection)|**Ping/echo**|한 구성 요소가 Ping을 발행하고 Echo를 받아 생존 상태를 확인함.||
||**Heartbeat**|한 구성 요소가 주기적으로 I’m alive(살아있음) 메시지를 보냄.||
||**Exception Detection**|시스템 예외(e.g., 0으로 나누기)나 시간 초과 예외를 감지함.||
||**Voting (투표)**|중복된 구성 요소의 결과를 비교하여 잘못된 결과를 식별함.||
|**결함 복구 - 준비 및 수리** (Preparation and Repair)|**Active Redundancy (Hot Spare)**|활성 구성 요소가 이벤트를 처리하고 상태 변경을 모든 예비 구성 요소에 동기적으로 알림.||
||**Passive Redundancy (Warm Spare)**|활성 구성 요소가 이벤트를 처리하고 상태 업데이트를 예비 구성 요소에 주기적으로 알림.||
||**Spare (Cold Spare)**|결함 감지 시 예비 구성 요소를 활성화함 (가용성은 가장 낮지만 비용이 저렴함).||
||**Rollback**|결함 감지 시 시스템을 이전에 알려진 양호한 상태(체크포인트)로 되돌림.||
||**Degradation**|구성 요소 고장 시 덜 중요한 기능을 삭제하고 가장 중요한 기능만 유지함.||
|**결함 복구 - 재도입** (Reintroduction)|**Escalating Restart**|구성 요소, 프로세스, 시스템 등 다양한 세분성 수준으로 재시작하여 결함으로부터 복구함.||
|**결함 예방** (Fault Prevention)|**Exception Prevention**|스마트 포인터/래퍼 등을 사용하여 시스템 예외가 발생하는 것을 방지함.||
### B. 상호 운용성 택틱 (Interoperability Tactics)

상호 운용성은 두 개 이상의 시스템이 의미 있는 정보를 유용하게 교환할 수 있는 정도입니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**위치 파악** (Locate)|**Discover Service**|알려진 디렉터리 서비스를 검색하여 서비스를 찾음.||
|**인터페이스 관리** (Manage Interfaces)|**Orchestrate (오케스트레이션)**|복잡한 작업을 수행하기 위해 특정 서비스 호출을 조정, 관리 및 순서화함 (워크플로우 엔진 사용).||
||**Tailor Interfaces**|구성 요소, 시스템 또는 서비스 간의 인터페이스를 맞춤화하거나 조정하여 호환성을 보장함 (Adapter, Decorator 패턴 사용).||
### C. 수정 용이성 택틱 (Modifiability Tactics)

수정 용이성은 시스템에 변경을 가하는 용이성(시간 또는 비용)에 관한 것입니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**결합도 감소** (Reduce Coupling)|**Encapsulate (캡슐화)**|책임 달성 세부 사항을 인터페이스 뒤에 숨김.||
||**Use an Intermediary (중개자 사용)**|중개자를 사용하여 통신 경로를 분리함 (Broker 패턴 등).||
||**Restrict Dependencies**|모듈의 가시성 또는 접근을 승인된 모듈로만 제한함 (e.g., 계층화 아키텍처).||
||**Abstract Common Services**|유사한 서비스를 보다 일반적인(추상적인) 형태로 구현함.||
|**응집도 증가** (Increase Cohesion)|**Increase Semantic Coherence**|의미적 응집도를 높여 관련 책임을 단일 모듈 내에 할당함.||
|**바인딩 시간 지연** (Defer Binding Time)|**Runtime Binding**|서비스 등록 및 검색, Publish-Subscribe, 다형성 등을 사용하여 런타임에 결정을 미룸.||
### D. 성능 택틱 (Performance Tactics)
성능은 이벤트 발생 시 시스템이 정해진 시간 내에 응답해야 하는지에 관한 것입니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**자원 관리** (Manage Resources)|**Increase Available Resources (자원 증가)**|더 많은 자원(e.g., 하드웨어)을 추가하여 성능을 향상시킴.||
||**Scheduling Policy (자원 스케줄링)**|자원 사용의 효율성을 높이기 위해 스케줄링 정책을 구현함.||
||**Introduce Concurrency (동시성 도입)**|병렬 처리를 통해 성능을 향상시킴 (e.g., Active Object 패턴).||
### E. 보안 택틱 (Security Tactics)

보안은 시스템이 무단 접근으로부터 데이터와 정보를 보호하는 능력입니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**공격 감지** (Detect Attacks)|**Verify Message Integrity**|메시지의 무결성을 확인하여 변조를 감지함.||
||**Detect Intrusion**|시스템에 대한 침입을 감지함.||
|**공격 방어** (Resist Attacks)|**Authenticate Actors**|행위자를 인증하여 접근 권한을 확인하고, 무단 접근을 방어함.||
||**Authorize Actors**|행위자에게 부여된 접근 권한을 기반으로 리소스 및 서비스에 대한 접근을 승인함.||
||**Limit Access**|DMZ(DeMilitarized Zone)와 같은 메커니즘을 통해 리소스 접근을 제어함.||
||**Separate Entities**|시스템 내의 다른 엔티티를 물리적/논리적으로 분리함.||
||**Encrypt Data**|데이터를 암호화하여 무단 접근으로부터 데이터를 보호함.||
|**공격 복구** (Recover from Attacks)|**Maintain Audit Trail**|보안 관련 활동에 대한 시간 순서 기록(Audit Log)을 유지하여 추후 분석에 활용함.||
### F. 테스트 용이성 택틱 (Testability Tactics)

테스트 용이성은 소프트웨어의 결함을 테스트를 통해 쉽게 입증할 수 있는 정도를 의미합니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**시스템 상태 제어 및 관찰**|**Specialized Interfaces**|구성 요소의 변수 값을 제어하거나 캡처하기 위한 특수 테스트 인터페이스.||
||**Record/Playback**|인터페이스를 가로지를 때 상태를 기록하여 결함을 재현하는 데 사용함.||
||**Abstract Data Sources**|추상 인터페이스를 통해 실제 데이터베이스 대신 테스트 데이터베이스나 파일로 대체하여 테스트를 용이하게 함.||
||**Sandbox**|격리된 테스트 환경을 제공하여 응용 프로그램, 시스템 또는 플랫폼에 영향을 주지 않고 프로그램을 실행할 수 있도록 함.||
|**복잡성 제한**|**Limit Structural Complexity**|구성 요소 간의 순환 종속성을 피하고, 일반적으로 구성 요소 간의 종속성을 줄임.||
### G. 사용 용이성 택틱 (Usability Tactics)

사용 용이성은 사용자가 원하는 작업을 얼마나 쉽게 달성할 수 있는지, 그리고 시스템이 제공하는 사용자 지원 유형에 관한 것입니다.

|분류|택틱 (Tactic)|설명|출처|
|:--|:--|:--|:--|
|**사용자 주도 지원** (Support User Initiative)|**Cancel, Undo, Pause/Resume**|사용자가 오류의 영향을 최소화하고 효율적으로 시스템을 사용할 수 있도록 함.||
||**Aggregate**|여러 단계를 하나의 작업으로 집계하여 효율적인 사용을 지원함.||
|**시스템 주도 지원** (Support System Initiative)|**Maintain Task Model**|사용자 의도를 파악하고 지원을 제공하기 위해 작업 모델을 유지함.||
||**Maintain User Model**|사용자의 시스템 지식을 명시적으로 나타내어 맞춤형 지원을 제공함.||
