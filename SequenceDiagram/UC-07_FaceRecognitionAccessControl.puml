@startuml UC07_FaceRecognitionAccessControl
title UC-07: 안면인식 출입 인증 (Face Recognition Access Control)
autonumber

' Actors
actor "Branch Equipment\n(Camera & Gate)" as Equipment

' Access Service Node - Interface Layer
box "Access Service Node" #LightBlue
  participant "AccessControlController\n<<Interface>>" as Controller
  participant "AccessAuthorizationManager\n<<Business>>" as AuthManager
  participant "FaceVectorCache\n<<Business>>" as Cache
  participant "GateController\n<<Business>>" as GateCtrl
  participant "AccessEventProcessor\n<<Business>>" as EventProc
  participant "FaceModelServiceIPCClient\n<<System Interface>>" as IPCClient
  participant "EquipmentGatewayAdapter\n<<System Interface>>" as EquipGW
  participant "VectorRepository\n<<System Interface>>" as VectorRepo
  participant "RabbitMQAdapter\n<<System Interface>>" as MQ
end box

' FaceModel Service Node (Same Physical Node - DD-05)
box "FaceModel Service Node\n(Co-located with Access)" #LightGreen
  participant "FaceModelIPCHandler\n<<Interface>>" as IPCHandler
  participant "VectorComparisonEngine\n<<Business>>" as VectorEngine
  participant "FeatureExtractor\n<<Business>>" as Extractor
  participant "MLInferenceEngineAdapter\n<<System Interface>>" as MLAdapter
end box

database "VectorDatabase" as VectorDB
queue "RabbitMQ Broker" as Broker

== Main Success Scenario ==

' Step 1: Equipment sends face photo
Equipment -> Controller : POST /access/face-recognition\n{facePhoto, branchId, equipmentId}
note right
  **DD-05: Data Pre-Fetching**
  Top 10K active face vectors
  preloaded in cache
  Hit rate: >90%
end note

' Step 2: Controller delegates to AuthManager
Controller -> AuthManager : recognizeAndAuthorize(facePhoto, branchId)

' Step 2.1: Check cache first (DD-05: Data Pre-Fetching)
AuthManager -> Cache : getActiveVectors(branchId)
Cache --> AuthManager : List<FaceVectorDto>
note left
  **Tactic: Data Pre-Fetching**
  Cache hit: ~5ms
  Cache miss: DB lookup ~50ms
end note

' Step 2.2: If cache miss, load from DB
alt Cache Miss
  AuthManager -> VectorRepo : findByBranchId(branchId)
  VectorRepo -> VectorDB : SELECT * FROM face_vectors\nWHERE branch_id = ?
  VectorDB --> VectorRepo : ResultSet
  VectorRepo --> AuthManager : List<FaceVectorDto>
  AuthManager -> Cache : updateCache(vectors)
end

' Step 3: Call FaceModel Service via IPC (DD-05)
AuthManager -> IPCClient : calculateSimilarityScore(facePhoto, storedVectors)
note right
  **DD-05: Same Physical Node**
  IPC/gRPC: minimum latency
  Shared memory optimization
  No network overhead
end note

IPCClient -> IPCHandler : <<IPC/gRPC>> calculateSimilarityScore()

' Step 4: Parallel Feature Extraction (DD-05: Pipeline Optimization)
IPCHandler -> VectorEngine : compareVectors(requestedImage, storedVectors)

par Parallel Feature Extraction
  VectorEngine -> Extractor : extractFeatures(requestedImage)
  Extractor -> MLAdapter : <<Local>> inferFeatures(requestedImage)
  MLAdapter --> Extractor : featureVector1
  Extractor --> VectorEngine : featureVector1
else
  VectorEngine -> Extractor : extractFeatures(storedVector)
  Extractor -> MLAdapter : <<Local>> inferFeatures(storedVector)
  MLAdapter --> Extractor : featureVector2
  Extractor --> VectorEngine : featureVector2
end

note over VectorEngine
  **DD-05: Pipeline Optimization**
  CompletableFuture parallelization:
  
  Total: max(200ms, 200ms) + 5ms = ~205ms
  vs Sequential: 200 + 200 + 5 = 405ms
  **49% latency reduction**
  
  Internal method:
  - cosineSimilarity(v1, v2)
end note

' Step 5: Calculate similarity (internal method)
VectorEngine -> VectorEngine : cosineSimilarity(v1, v2)
note right
  Internal calculation
  (not a separate component)
  ~5ms
end note

' Step 6: Return result
VectorEngine --> IPCHandler : SimilarityResultDto\n{userId, score, matched}
IPCHandler --> IPCClient : <<IPC/gRPC>> SimilarityResultDto
IPCClient --> AuthManager : SimilarityResultDto

' Step 7: User identification
AuthManager -> AuthManager : identifyUser(similarityResult)
note left
  **QAS-02 Target**
  Total response time: < 3초
  - Cache lookup: ~5ms
  - IPC call: ~205ms
  - User identification: ~10ms
  - Total: ~220ms ✓
end note

alt User Identified (similarity >= threshold)
  ' Step 8: Include UC-22 Gate Open
  AuthManager -> GateCtrl : openGate(equipmentId, userId)
  
  GateCtrl -> EquipGW : sendGateOpenCommand(equipmentId)
  EquipGW -> Equipment : <<HTTPS>> POST /equipment/gate/open
  note right
    **UC-22: Gate Open Execution**
    Target: < 1초 (QAS-02)
  end note
  
  Equipment --> EquipGW : {status: "success"}
  EquipGW --> GateCtrl : GateCommandResult
  GateCtrl --> AuthManager : GateOpenResult
  
  ' Step 9: Record access log and publish event
  AuthManager -> EventProc : recordAccessEvent(userId, branchId, result)
  EventProc -> VectorRepo : saveAccessLog(accessLog)
  VectorRepo -> VectorDB : INSERT INTO access_logs
  VectorDB --> VectorRepo : saved
  VectorRepo --> EventProc : saved
  
  EventProc -> MQ : publish(AccessGrantedEvent)
  MQ -> Broker : <<AMQP>> AccessGrantedEvent
  
  EventProc --> AuthManager : eventPublished
  AuthManager --> Controller : AccessResult{success, userId, timestamp}
  Controller --> Equipment : HTTP 200 OK\n{result: "success", userId, message}
  
else User Not Identified (Alternative 3a)
  ' Alternative 3a: Recognition Failed
  note over AuthManager
    **Alternative 3a**
    Similarity < threshold
    No user identified
  end note
  
  AuthManager -> EventProc : recordAccessDenied(facePhoto, branchId, reason)
  EventProc -> VectorRepo : saveAccessLog(accessLog)
  VectorRepo -> VectorDB : INSERT INTO access_logs\n(result='DENIED')
  VectorDB --> VectorRepo : saved
  VectorRepo --> EventProc : saved
  
  EventProc -> MQ : publish(AccessDeniedEvent)
  MQ -> Broker : <<AMQP>> AccessDeniedEvent
  
  EventProc --> AuthManager : eventPublished
  AuthManager --> Controller : AccessResult{failure, reason}
  Controller --> Equipment : HTTP 200 OK\n{result: "denied", message}
  
  note right
    **No Gate Opening**
    Failed access logged for
    security audit trail
  end note
end

== QAS-02 Performance Achievement ==
note over Equipment, MLAdapter
  **QAS-02: 신속하고 정확한 안면인식 출입 인증**
  
  **Performance Tactics Applied:**
  1. **Data Pre-Fetching**: Cache hit ~5ms (90%+ hit rate)
  2. **Pipeline Optimization**: Parallel feature extraction (49% faster)
  3. **Same Physical Node**: IPC/gRPC eliminates network latency
  4. **Introduce Concurrency**: CompletableFuture parallelization
  
  **Measured Performance:**
  - 90% requests: < 3초 (target met) ✓
  - 99% requests: < 5초 (target met) ✓
  - Gate open: < 1초 after recognition ✓
  
  **Peak Load (20 TPS for 1 min):**
  - Concurrent request handling via thread pool
  - Cache prevents DB bottleneck
  - IPC avoids network serialization overhead
end note

@enduml

